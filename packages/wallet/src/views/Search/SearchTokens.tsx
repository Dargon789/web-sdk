import { SearchIcon, TextInput } from '@0xsequence/design-system'
import { getNativeTokenInfoByChainId, ContractVerificationStatus, compareAddress } from '@0xsequence/kit'
import { ethers } from 'ethers'
import Fuse from 'fuse.js'
import { useState, useEffect } from 'react'
import { useAccount, useConfig } from 'wagmi'

import { useSettings } from '../../hooks'
import { computeBalanceFiat } from '../../utils'

import { CoinsTab } from './components/CoinsTab'
import { useGetTokenBalancesSummary, useGetCoinPrices, useGetExchangeRate } from '@0xsequence/kit-hooks'

export interface IndexedData {
  index: number
  name: string
}

export const SearchTokens = () => {
  const { chains } = useConfig()
  const { fiatCurrency, hideUnlistedTokens, selectedNetworks } = useSettings()
  const [search, setSearch] = useState('')

  const pageSize = 20
  const [displayedCoinBalances, setDisplayedCoinBalances] = useState<IndexedData[]>([])

  const [displayedSearchCoinBalances, setDisplayedSearchCoinBalances] = useState<IndexedData[]>([])

  const [initCoinsFlag, setInitCoinsFlag] = useState(false)

  const [hasMoreCoins, sethasMoreCoins] = useState(false)

  const [hasMoreSearchCoins, sethasMoreSearchCoins] = useState(false)

  const { address: accountAddress } = useAccount()

  const { data: tokenBalancesData, isPending: isPendingTokenBalances } = useGetTokenBalancesSummary({
    chainIds: selectedNetworks,
    filter: {
      accountAddresses: accountAddress ? [accountAddress] : [],
      contractStatus: hideUnlistedTokens ? ContractVerificationStatus.VERIFIED : ContractVerificationStatus.ALL,
      omitNativeBalances: false
    }
  })

  const coinBalancesUnordered =
    tokenBalancesData?.filter(b => b.contractType === 'ERC20' || compareAddress(b.contractAddress, ethers.ZeroAddress)) || []

  const { data: coinPrices = [], isPending: isPendingCoinPrices } = useGetCoinPrices(
    coinBalancesUnordered.map(token => ({
      chainId: token.chainId,
      contractAddress: token.contractAddress
    }))
  )

  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useGetExchangeRate(fiatCurrency.symbol)

  const coinBalances = coinBalancesUnordered.sort((a, b) => {
    const fiatA = computeBalanceFiat({
      balance: a,
      prices: coinPrices,
      conversionRate,
      decimals: a.contractInfo?.decimals || 18
    })
    const fiatB = computeBalanceFiat({
      balance: b,
      prices: coinPrices,
      conversionRate,
      decimals: b.contractInfo?.decimals || 18
    })
    return Number(fiatB) - Number(fiatA)
  })

  const coinBalancesAmount = coinBalances.length

  const isPending = isPendingTokenBalances || isPendingCoinPrices || isPendingConversionRate

  const indexedCoinBalances: IndexedData[] = coinBalances.map((balance, index) => {
    if (compareAddress(balance.contractAddress, ethers.ZeroAddress)) {
      const nativeTokenInfo = getNativeTokenInfoByChainId(balance.chainId, chains)

      return {
        index,
        name: nativeTokenInfo.name
      }
    } else {
      return {
        index,
        name: balance.contractInfo?.name || 'Unknown'
      }
    }
  })

  useEffect(() => {
    if (!initCoinsFlag && indexedCoinBalances.length > 0) {
      setDisplayedCoinBalances(indexedCoinBalances.slice(0, pageSize))
      sethasMoreCoins(indexedCoinBalances.length > pageSize)
      setInitCoinsFlag(true)
    }
  }, [initCoinsFlag])

  useEffect(() => {
    if (search !== '') {
      setDisplayedSearchCoinBalances(
        fuzzySearchCoinBalances
          .search(search)
          .map(result => result.item)
          .slice(0, pageSize)
      )
      sethasMoreSearchCoins(fuzzySearchCoinBalances.search(search).length > pageSize)
    }
  }, [search])

  const fetchMoreCoinBalances = () => {
    if (displayedCoinBalances.length >= indexedCoinBalances.length) {
      sethasMoreCoins(false)
      return
    }
    setDisplayedCoinBalances(indexedCoinBalances.slice(0, displayedCoinBalances.length + pageSize))
  }

  const fetchMoreSearchCoinBalances = () => {
    if (displayedSearchCoinBalances.length >= fuzzySearchCoinBalances.search(search).length) {
      sethasMoreSearchCoins(false)
      return
    }
    setDisplayedSearchCoinBalances(
      fuzzySearchCoinBalances
        .search(search)
        .map(result => result.item)
        .slice(0, displayedSearchCoinBalances.length + pageSize)
    )
  }

  const fuzzySearchCoinBalances = new Fuse(indexedCoinBalances, {
    keys: ['name']
  })

  return (
    <div className="flex px-4 pb-5 pt-3 flex-col gap-5 items-center justify-center">
      <div className="w-full">
        <TextInput
          autoFocus
          name="search wallet"
          leftIcon={SearchIcon}
          value={search}
          onChange={ev => setSearch(ev.target.value)}
          placeholder="Search your wallet"
          data-1p-ignore
        />
      </div>
      <div className="w-full">
        <CoinsTab
          displayedCoinBalances={search ? displayedSearchCoinBalances : displayedCoinBalances}
          fetchMoreCoinBalances={fetchMoreCoinBalances}
          fetchMoreSearchCoinBalances={fetchMoreSearchCoinBalances}
          hasMoreCoins={hasMoreCoins}
          hasMoreSearchCoins={hasMoreSearchCoins}
          isSearching={search !== ''}
          isPending={isPending}
          coinBalances={coinBalances}
        />
      </div>
    </div>
  )
}
